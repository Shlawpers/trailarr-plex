{
  "version": 3,
  "sources": ["src/app/models/media.ts", "src/app/services/media.service.ts"],
  "sourcesContent": ["export interface Media {\n  is_movie: boolean;\n  connection_id: number;\n  arr_id: number;\n  title: string;\n  clean_title: string;\n  year: number;\n  language: string;\n  studio: string;\n  media_exists: boolean;\n  media_filename: string;\n  overview: string;\n  runtime: number;\n  youtube_trailer_id: string;\n  folder_path: string;\n  imdb_id: string;\n  txdb_id: string;\n  title_slug: string;\n  poster_url: string;\n  fanart_url: string;\n  poster_path: string;\n  fanart_path: string;\n  trailer_exists: boolean;\n  monitor: boolean;\n  arr_monitored: boolean;\n  status: string;\n  id: number;\n  added_at: Date;\n  updated_at: Date;\n  downloaded_at: Date;\n\n  // Additional properties\n  isImageLoaded: boolean;\n}\n\nexport function mapMedia(media: any): Media {\n  return {\n    ...media,\n    added_at: new Date(`${media.added_at}Z`),\n    updated_at: new Date(`${media.updated_at}Z`),\n    downloaded_at: new Date(`${media.downloaded_at}Z`),\n    isImageLoaded: false,\n  };\n}\n\nexport interface SearchMedia {\n  id: number;\n  title: string;\n  year: number;\n  youtube_trailer_id: string;\n  imdb_id: string;\n  txdb_id: string;\n  is_movie: boolean;\n  poster_path: string | null;\n}\n\nexport interface FolderInfo {\n  type: string;\n  name: string;\n  size: string;\n  path: string;\n  files: FolderInfo[];\n  modified: Date;\n  isExpanded: boolean;\n}\n\nexport function mapFolderInfo(folder: any): FolderInfo {\n  let _files = [\n    {\n      type: 'folder',\n      name: 'None',\n      size: '',\n      path: '',\n      files: [],\n      modified: new Date(),\n      isExpanded: false,\n    },\n  ];\n  if (folder.files) {\n    _files = folder.files.map((file: any) => (isFile(file) ? mapFileInfo(file) : mapFolderInfo(file)));\n  }\n  return {\n    ...folder,\n    isExpanded: false,\n    modified: new Date(`${folder.created}Z`),\n    files: _files,\n  };\n}\n\nfunction mapFileInfo(file: any): FolderInfo {\n  return {\n    ...file,\n    isExpanded: false,\n    modified: new Date(`${file.created}Z`),\n  };\n}\n\nfunction isFile(file: any): boolean {\n  // Implement this function based on how you differentiate between a file and a folder in your data.\n  // For example, you might check a 'type' property:\n  return file.type === 'file';\n}\n", "import {HttpClient, HttpParams} from '@angular/common/http';\nimport {inject, Injectable} from '@angular/core';\nimport {catchError, firstValueFrom, map, Observable, of} from 'rxjs';\nimport {environment} from '../../environment';\nimport {FolderInfo, mapFolderInfo, mapMedia, Media, SearchMedia} from '../models/media';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class MediaService {\n  private readonly httpClient = inject(HttpClient);\n\n  private mediaUrl = environment.apiUrl + environment.media;\n\n  // allMedia = signal<Media[]>([]);\n\n  // Add a getter for the allMedia signal\n  // getAllMedia() {\n  //   return this.allMedia;\n  // }\n\n  /**\n   * Fetches all media items from the server, maps them, and saves them to the allMedia signal.\n   *\n   * @param {boolean | null} moviesOnly\n   * Flag to specify what Media items to fetch. Default is `null`.\n   * - If `true`, only movies will be fetched.\n   * - If `false`, only series will be fetched.\n   * - If `null`, both movies and series will be fetched.\n   * @param {string} [filterBy='all']\n   * The field by which to filter the media items. Default is `'all'`. \\\n   * Possible values are:\n   * - `all`: Fetch all media items.\n   * - `downloaded`: Fetch only downloaded media items.\n   * - `monitored`: Fetch only monitored media items.\n   * - `missing`: Fetch only missing media items.\n   * - `unmonitored`: Fetch only unmonitored media items.\n   * @returns {void}\n   */\n  fetchAllMedia(moviesOnly: boolean | null, filterBy: string = 'all') {\n    // Fetch all media items from the server, map them, and save them to the allMedia signal\n    const url = `${this.mediaUrl}all`;\n    let params: HttpParams;\n    if (moviesOnly !== null) {\n      params = new HttpParams().set('movies_only', moviesOnly).set('filter_by', filterBy);\n    } else {\n      params = new HttpParams().set('filter_by', filterBy);\n    }\n    return this.httpClient.get<any[]>(url, {params: params});\n  }\n\n  /**\n   * Fetches updated media items from the server and updates the allMedia signal.\n   *\n   * @returns {void}\n   */\n  fetchUpdatedMedia(seconds: number) {\n    // Fetch updated media items from the server and update the allMedia signal\n    const url = `${this.mediaUrl}updated`;\n\n    const params = new HttpParams().set('seconds', seconds);\n    return this.httpClient.get<any[]>(url, {params: params});\n  }\n\n  /**\n   * Fetches a list of recently downloaded media items. Max 50 items.\n   *\n   * @param moviesOnly - Flag to specify what Media items to fetch. \\\n   * - If `true`, only movies will be fetched. \\\n   * - If `false`, only series will be fetched. \\\n   * - If `null`, both movies and series will be fetched.\n   * @returns An Observable that emits an array of Media objects.\n   */\n  fetchRecentlyDownloaded(moviesOnly: boolean | null): Observable<Media[]> {\n    let url = `${this.mediaUrl}downloaded`;\n    let params = new HttpParams();\n    if (moviesOnly !== null) {\n      params = new HttpParams().set('limit', '50').set('movies_only', moviesOnly);\n    } else {\n      params = new HttpParams().set('limit', '50');\n    }\n    // Else, Fetch the filtered media list from the server\n    return this.httpClient.get<Media[]>(url, {params: params}).pipe(\n      map((media_list: any[]) => {\n        return media_list.map((media) => mapMedia(media));\n      }),\n    );\n  }\n\n  /**\n   * Retrieves a media item by its ID from the server.\n   *\n   * @param mediaID - The ID of the media item to retrieve.\n   * @returns An observable of the media item.\n   */\n  getMediaByID(mediaID: number): Observable<Media> {\n    const url = `${this.mediaUrl}${mediaID}`;\n    return this.httpClient.get<any>(url).pipe(map((media) => mapMedia(media)));\n  }\n\n  /**\n   * Retrieves the previous media item in the list based on the provided media ID.\n   *\n   * @param {number} mediaID - The ID of the current media item.\n   * @returns {Media | null} - The previous media item if it exists, otherwise null.\n   */\n  // getPreviousMedia(mediaID: number): Media | null {\n  //   let mediaList = this.allMedia();\n  //   let index = mediaList.findIndex(media => media.id === mediaID);\n  //   if (index > 0) {\n  //     return mediaList[index - 1];\n  //   }\n  //   return null;\n  // }\n\n  /**\n   * Retrieves the next media item in the list based on the provided media ID.\n   *\n   * @param {number} mediaID - The ID of the current media item.\n   * @returns {Media | null} - The next media item if it exists, otherwise null.\n   */\n  // getNextMedia(mediaID: number): Media | null {\n  //   let mediaList = this.allMedia();\n  //   let index = mediaList.findIndex(media => media.id === mediaID);\n  //   if (index < mediaList.length - 1) {\n  //     return mediaList[index + 1];\n  //   }\n  //   return null;\n  // }\n\n  /**\n   * Searches for media items that match the given search term.\n   *\n   * @param searchTerm - The term to search for within the media titles.\n   * @returns An array of media items whose titles include the search term.\n   */\n  searchMedia(searchTerm: string): Observable<SearchMedia[]> {\n    let url = `${this.mediaUrl}search`;\n    let params = new HttpParams().set('query', searchTerm);\n    return this.httpClient.get<SearchMedia[]>(url, {params: params});\n  }\n\n  /**\n   * Updates the status of multiple media items in a batch operation.\n   *\n   * @param mediaIDs - An array of media item IDs to update.\n   * @param action - The action to perform on the media items. \\\n   * Possible values are:\n   * - `monitor`: Monitor the specified media items.\n   * - `unmonitor`: Unmonitor the specified media items.\n   * - `delete`: Delete the trailers for specified media items.\n   * - `download`: Download the trailers specified media items.\n   * @param profileID - The ID of the profile to use for the batch update. \\\n   * If not provided, defaults to -1. \\\n   * Only required for `download` action.\n   * @returns An Observable that emits the response from the server.\n   */\n  batchUpdate(mediaIDs: number[], action: string, profileID: number = -1): Observable<any> {\n    const url = `${this.mediaUrl}batch_update`;\n    return this.httpClient.post(url, {\n      media_ids: mediaIDs,\n      action: action.toLowerCase(),\n      profile_id: profileID,\n    });\n  }\n\n  /**\n   * Downloads a trailer for a Media item.\n   *\n   * @param mediaID - The ID of the Media item to download the trailer for.\n   * @param profileID - The ID of the profile to use for downloading the trailer.\n   * @param ytID - The YouTube ID of the trailer to download. Can be an empty string.\n   * @returns - An Observable that emits the response from the server.\n   * - If an error occurs during the request, the Observable will emit an error.\n   */\n  downloadMediaTrailer(mediaID: number, profileID: number, ytID: string): Observable<any> {\n    const params = new HttpParams().set('profile_id', profileID).set('yt_id', ytID);\n    const url = `${this.mediaUrl}${mediaID}/download`;\n    return this.httpClient.post(url, {}, {params: params});\n  }\n\n  /**\n   * Toggles the monitoring status of a Media item.\n   *\n   * @param mediaID - The ID of the Media item to toggle the monitoring status for.\n   * @param monitor - If `true`, the Media item will be monitored. \\\n   * If `false`, the Media item will not be monitored.\n   * @returns An Observable that emits the response from the server.\n   * If an error occurs during the request, the Observable will emit an error.\n   */\n  monitorMedia(mediaID: number, monitor: boolean): Observable<any> {\n    const params = new HttpParams().set('monitor', monitor);\n    const url = `${this.mediaUrl}${mediaID}/monitor`;\n    return this.httpClient.post(url, {}, {params: params});\n  }\n\n  /**\n   * Deletes the trailer for a Media item.\n   *\n   * @param mediaID - The ID of the Media item to delete the trailer for.\n   * @returns An Observable that emits the response from the server.\n   * If an error occurs during the request, the Observable will emit an error.\n   */\n  deleteMediaTrailer(mediaID: number): Observable<any> {\n    const url = `${this.mediaUrl}${mediaID}/trailer`;\n    return this.httpClient.delete(url);\n  }\n\n  /**\n   * Fetches the files for a Media item.\n   *\n   * @param mediaID - The ID of the Media item to fetch the files for.\n   * @returns An Observable that emits a `FolderInfo` object with the files for the specified Media item. \\\n   * If no files are found for the specified Media item, the Observable will emit a string. \\\n   * If an error occurs during the request, the Observable will emit an error.\n   */\n  getMediaFiles(mediaID: number): Observable<any> {\n    const url = `${this.mediaUrl}${mediaID}/files`;\n    return this.httpClient.get(url).pipe(\n      map((response) => {\n        if (typeof response === 'string') {\n          // Handle the string response\n          return response;\n        } else {\n          // Map the FolderInfo object\n          return mapFolderInfo(response);\n        }\n      }),\n      catchError((error) => {\n        // Handle error appropriately\n        console.error('Error fetching media files:', error);\n        return of(`Error: ${error.message}`);\n      }),\n    );\n  }\n\n  async fetchMediaFiles(mediaID: number): Promise<FolderInfo> {\n    const url = `${this.mediaUrl}${mediaID}/files`;\n    const files = await firstValueFrom(this.httpClient.get<FolderInfo>(url));\n    return mapFolderInfo(files);\n  }\n\n  /**\n   * Searches for a media trailer by its ID.\n   *\n   * @param {number} mediaID - The ID of the media to search for.\n   * @param {number} profileID - The ID of the profile to use for the search.\n   * @returns {Observable<any>} An observable containing the search results.\n   */\n  searchMediaTrailer(mediaID: number, profileID: number): Observable<any> {\n    const params = new HttpParams().set('profile_id', profileID);\n    const url = `${this.mediaUrl}${mediaID}/search`;\n    return this.httpClient.post(url, {}, {params: params});\n  }\n\n  /**\n   * Saves the media trailer by sending a POST request to update the media with the given YouTube ID.\n   *\n   * @param {number} mediaID - The ID of the media to update.\n   * @param {string} ytID - The YouTube ID of the trailer to be saved.\n   * @returns {Observable<any>} An observable that emits the response from the server.\n   */\n  saveMediaTrailer(mediaID: number, ytID: string): Observable<any> {\n    const url = `${this.mediaUrl}${mediaID}/update`;\n    const params = new HttpParams().set('yt_id', ytID);\n    return this.httpClient.post(url, {}, {params: params});\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
